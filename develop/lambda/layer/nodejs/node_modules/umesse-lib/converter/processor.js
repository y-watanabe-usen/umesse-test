'use strict';

const fs = require('fs')
const { debuglog } = require('../constants')
const { execSync } = require("child_process");

module.exports = function (proto) {

  proto.init = function () {
    fs.rmSync(this.workDir, { force: true, recursive: true })
    fs.mkdirSync(this.workDir, { recursive: true })
  }
  proto.writeFile = function (filename, data) {
    fs.writeFileSync(`${this.workDir}/${filename}`, data);
  }
  proto.readFileStream = function (filename) {
    return fs.createReadStream(`${this.workDir}/${filename}`);
  }
/*
  proto.generateCm = function (inputs, output) {
    var inputParam = '';
    for (const [index, value] of inputs.entries()) {
      inputParam +=` -i ${value} `;
    }
    let command = `${this.ffmpeg} ${inputParam} \
        -filter_complex ' \
          [0:a]volume=0.5[start_chime]; \
          [1:a]volume=0.5,adelay=3s|3s[end_chime]; \
          [2:a]volume=0.5,aloop=2:2.14748e+009[bgm]; \
          [3:a]volume=3.0,adelay=3s|3s[narration1]; \
          [4:a]volume=3.0,adelay=3s|3s[narration2]; \
          [5:a]volume=3.0,adelay=3s|3s,apad=pad_dur=5[narration3]; \
          [narration1][narration2][narration3]concat=n=3:v=0:a=1[join]; \
          [join][bgm]amix=duration=shortest[mix]; \
          [mix][end_chime]acrossfade=d=3[last]; \
          [start_chime][last]concat=n=2:v=0:a=1 \
        ' -y ${output}`;
    debuglog(command);
    execSync(command);
    if (fs.existsSync(output)) {
      return true
    }
    return false
  }
  proto.getDuration = function (input) {
    let secondsCommand = `${this.ffmpeg} -hide_banner -i ${input} 2>&1 | \
      grep 'Duration' | cut -d ' ' -f 4 | cut -d '.' -f 1`
    const seconds = execSync(secondsCommand)
      .toString()
      .replace(/\n/g, "");
    debuglog(`seconds: ${seconds}`);
    return seconds;
  }
  */

  // 1. wav変換
  proto.toWav = function (input, output) {
    command = `${this.ffmpeg} -y -i ${input} \
        -ar 44100 -acodec pcm_s16le -ac 2 -map_metadata -1 -flags +bitexact ${output}`;
    debuglog(command);
    execSync(command);
    if (fs.existsSync(output)) {
      return true
    }
    return false
  }

  // 2. ラウドネス値取得
  proto.getLoudnorm = function (input, params) {
    command = `${this.ffmpeg} -i ${input} \
        -af loudnorm=I=${params.I}:LRA=${params.LRA}:tp=${params.tp}:print_format=json -f null - 2>&1 | tail -12`;
    console.log(command);
    res = execSync(command);
    data = JSON.parse(res.toString());
    return data;
  }

  // 3. ラウドネス調整 + 音圧調整
  proto.muasured = function (input, output, data) {
    command = `${this.ffmpeg} -y -i ${input} \
        -af loudnorm=I=-24.0:LRA=+20.0:tp=-2.0:measured_I=${data.input_i}:measured_LRA=${data.input_lra}:measured_tp=${data.input_tp}:measured_thresh=${data.input_thresh}:offset=${data.target_offset},acompressor=threshold=-35dB:ratio=1.7:attack=200,alimiter=limit=-17dB:level=false:level_out=17dB \
        -ar 44100 ${output}`;
    debuglog(command);
    execSync(command);
    if (fs.existsSync(output)) {
      return true
    }
    return false
  }


  // 5. ラウドネス調整 + HE-AACv2化
  proto.measuredLoudnorm = function (input, output, data) {
    command = `${this.ffmpeg} -y -i ${input} \
        -af volume=0dB -acodec libfdk_aac -profile:a aac_he_v2 -ab 48k -ar 48000 -ac 2 ${output}`;
    if (data.input_i > -17.5) {
      command = `${this.ffmpeg} -y -i ${input} \
          -af volume=-${parseFloat(data.input_i) + 17.5
        }dB -acodec libfdk_aac -profile:a aac_he_v2 -ab 48k -ar 48000 -ac 2 ${output}`;
    }
    debuglog(command);
    execSync(command);

    if (fs.existsSync(output)) {
      return true
    }
    return false
  }

}