'use strict';

const fs = require('fs');
const path = require('path');

const { debuglog, constants } = require('umesse-lib');
const ffmpeg = require('fluent-ffmpeg');

module.exports = function (proto) {
  proto.getFFMpeg = function () {
    return ffmpeg();
  }

  // Cleanup Workdir.
  proto.init = async function () {
  }
  proto.createReadStream = function (input) {
    return fs.createReadStream(input);
  }

  proto.generateCm = async function (unisCustomerCd, cmId, materials, output) {
    const workDir = this.getWorkDir(unisCustomerCd, cmId);
    // Initialized workdir.
    if (fs.existsSync(workDir)) {
      fs.rmdirSync(workDir, { recursive: true })
    }
    fs.mkdirSync(workDir, { recursive: true })

    // S3から無音ファイルを取得
    const filePath = this.basePath;
    const fileName = 'silent.mp3';
    if (!fs.existsSync(path.join(filePath, fileName))) {
      if (!(await this.getContents(constants.s3Bucket().contents, fileName, filePath, fileName)))
        throw "getObject failed";
    }

    const has = {
      startChime: "startChime" in materials,
      endChime: "endChime" in materials,
      bgm: "bgm" in materials,
    };
    console.log(`proto.generateCm()`);

    let paths = ["/tmp/umesse/silent.mp3"];
    let options = [];
    let extra = [];
    let index = 0;

    // S3からファイル取得、コマンド作成
    for (let [key, value] of Object.entries(materials).sort()) {
      debuglog(JSON.stringify({ key: key, value: value }));
      let fileName = "";

      switch (key) {
        case "narrations":
          let count = 0;
          let narrations = "";

          for (let v of value) {
            let target = `narration/${v.id}.mp3`;
            let bucket = constants.s3Bucket().contents;

            if (v.category == constants.resourceCategory.RECORDING || v.category == constants.resourceCategory.TTS) {
              // レコーディング音源orTTS音源の場合
              target = `users/${unisCustomerCd}/${v.category}/${v.id}.mp3`;
              bucket = constants.s3Bucket().users;
            }

            fileName = `narration_${++count}`;
            if (!(await this.getContents(bucket, target, workDir, `${fileName}.mp3`)))
              throw "getObject failed";
            paths.push(`${workDir}/${fileName}.mp3`);
            narrations += `[${fileName}]`;
            // 無音カット ボリューム調整　末尾に3秒無音追加
            options.push(this.createCommand(["silent", "volume", "apad"], `[${++index}:a]`, v.volume, 3, fileName));
          }
          // ナレーションを結合
          extra.push(this.createCommand(["concat"], narrations, null, count, "mix"));
          if (has.bgm) {
            // BGMがある場合は、前後に3秒無音追加
            extra.push(this.createCommand(["adelay", "apad"], "[mix]", null, 3, "mix"));
          }
          break;

        case "startChime":
          fileName = "start_chime";
          if (!(await this.getContents(constants.s3Bucket().contents, `chime/${value.id}.mp3`, workDir, `${fileName}.mp3`)))
            throw "getObject failed";
          paths.push(`${workDir}/${fileName}.mp3`);
          // 無音カット ボリューム調整　末尾に1秒無音追加
          options.push(this.createCommand(["silent", "volume", "apad"], `[${++index}:a]`, value.volume, 1, fileName));
          break;

        case "endChime":
          fileName = "end_chime";
          if (!(await this.getContents(constants.s3Bucket().contents, `chime/${value.id}.mp3`, workDir, `${fileName}.mp3`)))
            throw "getObject failed";
          paths.push(`${workDir}/${fileName}.mp3`);
          // 無音カット ボリューム調整　頭にBGMあり3秒、BGMなし1秒無音追加
          options.push(this.createCommand(["silent", "volume", "adelay"], `[${++index}:a]`, value.volume, has.bgm ? 3 : 1, fileName));
          break;

        case "bgm":
          fileName = "bgm";
          if (!(await this.getContents(constants.s3Bucket().contents, `bgm/${value.id}.mp3`, workDir, `${fileName}.mp3`)))
            throw "getObject failed";
          paths.push(`${workDir}/${fileName}.mp3`);
          // 無音カット ボリューム調整　BGMを無限ループ
          options.push(this.createCommand(["silent", "volume", "aloop"], `[${++index}:a]`, value.volume, -1, fileName));
          break;
      }
    }

    if (has.bgm) {
      // 結合したナレーションとBGMをMIX
      extra.push(this.createCommand(["amix"], "[mix][bgm]", null, null, "mix"));
    }
    if (has.startChime) {
      // 結合したナレーションと開始チャイムを結合
      extra.push(this.createCommand(["concat"], "[start_chime][mix]", null, 2, "mix"));
    }
    if (has.endChime) {
      // 結合したナレーションと終了チャイムを結合、フェードアウト3秒
      extra.push(this.createCommand(["acrossfade"], "[mix][end_chime]", null, 3, "mix"));
    } else if (!has.endChime && has.bgm) {
      // 無音を3秒に伸ばす
      extra.push(this.createCommand(["adelay"], "[0:a]", null, 3, "silent"));
      // 結合したナレーションと無音を結合、フェードアウト3秒
      extra.push(this.createCommand(["acrossfade"], "[mix][silent]", null, 3, "mix"));
    }
    // 前後に無音を追加
    extra.push(this.createCommand(["concat"], "[0:a][mix][0:a]", null, 3, null));

    // MIX処理実施
    return new Promise(async (resolve, reject) => {
      let f = this.getFFMpeg();
      for (var x of paths) {
        f.input(x);
      }
      f.complexFilter([...options, ...extra])
        .on('data', (data) => {
          console.log(data);
        }).on('end', (stdout, stderr) => {
          console.log(stdout, stderr);
          resolve();
        }).on('error', function (err) {
          console.log(`error = ${err}`);
          reject(err)
        }).save(output);
    });
  }

  proto.getDuration = function (input) {
    // CMの秒数を取得
    return new Promise((resolve, reject) => {
      ffmpeg(input)
        .ffprobe(0, (err, data) => {
          if (err) return reject(err);
          resolve(data.format.duration)
        });
    })
  }
  /// ; が必要ないため、createCommandをここで上書き
  proto.createCommand = function (process, index, volume, num, div) {
    const command = {
      silent: `silenceremove=stop_periods=-1:stop_duration=1:stop_threshold=-90dB`,
      volume: `volume=${volume / 100}`,
      adelay: `adelay=${num}s|${num}s`,
      apad: `apad=pad_dur=${num}`,
      aloop: `aloop=${num}:2.14748e+009`,
      concat: `concat=n=${num}:v=0:a=1`,
      amix: `amix=duration=shortest`,
      acrossfade: `acrossfade=d=${num}`,
    };

    let res = `${index}`;
    let options = [];
    for (const key of process) {
      if (key in command) {
        options.push(command[key]);
      }
    }
    res += options.join();
    if (div) {
      res += `[${div}]`;
    }
    return res;
  }


  // 1. wav変換
  proto.toWav = function (input, output) {
    return new Promise((resolve, reject) => {
      ffmpeg(input)
        .audioCodec('pcm_s16le')
        .audioChannels(2)
        .audioFrequency(44100)
        .addOption('-map_metadata', -1)
        .addOption('-flags', "+bitexact")
        .format('wav')
        .on('data', (data) => {
          console.log(data);
        })
        .on('end', () => {
          resolve()
        })
        .on('error', function (err) {
          reject(err)
        }).save(output);
    });
  }

  // 2. ラウドネス値取得
  //  getLoudnorm(input, { I: "-12.0", LRA: "+10.0", tp="-2.0" })
  proto.getLoudnorm = function (input, params = { I: "-24.0", LRA: "+20.0", tp: "-2.0" }) {
    return new Promise((resolve, reject) => {
      ffmpeg(input)
        .withAudioFilter(`loudnorm=I=${params.I}:LRA=${params.LRA}:tp=${params.tp}:print_format=json`)
        .addOption('-f', 'null')
        .on('end', (stdout, stderr) => {
          try {
            const jsonstr = stderr.substring(stderr.indexOf("{"));
            const data = JSON.parse(jsonstr.toString());
            resolve(data)
          } catch (e) {
            reject(e)
          }
        })
        .on('error', function (err) {
          reject(err)
        }).save('-');
    });
  }
}