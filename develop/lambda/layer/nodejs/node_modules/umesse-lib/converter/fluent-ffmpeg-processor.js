"use strict";

const fs = require("fs");
const path = require("path");

const { debuglog, constants } = require("umesse-lib");
const ffmpeg = require("fluent-ffmpeg");

module.exports = function (proto) {
  proto.getFFMpeg = function () {
    return ffmpeg();
  };

  // Cleanup Workdir.
  proto.init = async function () {};
  proto.createReadStream = function (input) {
    return fs.createReadStream(input);
  };

  proto.generateCm = async function (
    unisCustomerCd,
    cmId,
    materials,
    output,
    callback
  ) {
    const workDir = this.getWorkDir(unisCustomerCd, cmId);
    // Initialized workdir.
    if (!fs.existsSync(workDir)) {
      fs.mkdirSync(workDir, { recursive: true });
    }

    // S3から無音ファイルを取得
    const filePath = this.basePath;
    const fileName = "silent.mp3";
    if (!fs.existsSync(path.join(filePath, fileName))) {
      if (
        !(await this.getContents(
          constants.s3Bucket().contents,
          fileName,
          filePath,
          fileName
        ))
      )
        throw "getObject failed";
    }

    const has = {
      startChime: "startChime" in materials,
      endChime: "endChime" in materials,
      bgm: "bgm" in materials,
    };
    console.log(`proto.generateCm()`);

    let paths = ["/tmp/umesse/silent.mp3"];
    let options = [];
    let extra = [];
    let index = 0;

    // S3からファイル取得、コマンド作成
    for (let [key, value] of Object.entries(materials).sort()) {
      debuglog(JSON.stringify({ key: key, value: value }));
      let fileName = "";

      switch (key) {
        case "narrations":
          let count = 0;
          let narrations = "";

          for (let v of value) {
            let target = `narration/${v.id}.mp3`;
            let bucket = constants.s3Bucket().contents;

            if (
              v.category == constants.resourceCategory.RECORDING ||
              v.category == constants.resourceCategory.TTS
            ) {
              // レコーディング音源orTTS音源の場合
              target = `users/${unisCustomerCd}/${v.category}/${v.id}.mp3`;
              bucket = constants.s3Bucket().users;
            }

            fileName = `narration_${++count}`;
            if (
              !(await this.getContents(
                bucket,
                target,
                workDir,
                `${fileName}.mp3`
              ))
            )
              throw "getObject failed";
            paths.push(`${workDir}/${fileName}.mp3`);
            narrations += `[${fileName}]`;
            // 無音カット ボリューム調整　末尾に3秒無音追加
            options.push(
              this.createCommand(
                ["volume", "apad"],
                `[${++index}:a]`,
                v.volume,
                3,
                fileName
              )
            );
          }
          // ナレーションを結合
          extra.push(
            this.createCommand(["concat"], narrations, null, count, "mix")
          );
          if (has.bgm) {
            // BGMがある場合は、前後に3秒無音追加
            extra.push(
              this.createCommand(["adelay", "apad"], "[mix]", null, 3, "mix")
            );
          }
          break;

        case "startChime":
          fileName = "start_chime";
          if (
            !(await this.getContents(
              constants.s3Bucket().contents,
              `chime/${value.id}.mp3`,
              workDir,
              `${fileName}.mp3`
            ))
          )
            throw "getObject failed";
          paths.push(`${workDir}/${fileName}.mp3`);
          // 無音カット ボリューム調整　末尾に1秒無音追加
          options.push(
            this.createCommand(
              ["silent", "volume", "apad"],
              `[${++index}:a]`,
              value.volume,
              1,
              fileName
            )
          );
          break;

        case "endChime":
          fileName = "end_chime";
          if (
            !(await this.getContents(
              constants.s3Bucket().contents,
              `chime/${value.id}.mp3`,
              workDir,
              `${fileName}.mp3`
            ))
          )
            throw "getObject failed";
          paths.push(`${workDir}/${fileName}.mp3`);
          // 無音カット ボリューム調整　頭にBGMあり2秒、BGMなし1秒無音追加
          options.push(
            this.createCommand(
              ["silent", "volume", "adelay"],
              `[${++index}:a]`,
              value.volume,
              has.bgm ? 2 : 1,
              fileName
            )
          );
          break;

        case "bgm":
          fileName = "bgm";
          if (
            !(await this.getContents(
              constants.s3Bucket().contents,
              `bgm/${value.id}.mp3`,
              workDir,
              `${fileName}.mp3`
            ))
          )
            throw "getObject failed";
          paths.push(`${workDir}/${fileName}.mp3`);
          // 無音カット ボリューム調整　BGMを無限ループ 2回目以降をフェードイン
          options.push(
            this.createCommand(
              ["silent", "volume", "afadeloop"],
              `[${++index}:a]`,
              value.volume,
              3,
              fileName
            )
          );
          break;
      }
    }

    if (has.bgm) {
      // 結合したナレーションとBGMをMIX
      extra.push(this.createCommand(["amix"], "[mix][bgm]", null, null, "mix"));
    }
    if (has.startChime) {
      // 結合したナレーションと開始チャイムを結合
      extra.push(
        this.createCommand(["concat"], "[start_chime][mix]", null, 2, "mix")
      );
    }
    if (has.endChime) {
      // 結合したナレーションと終了チャイムを結合、フェードアウト2秒
      extra.push(
        this.createCommand(["acrossfade"], "[mix][end_chime]", null, 2, "mix")
      );
    } else if (!has.endChime && has.bgm) {
      // 無音を3秒に伸ばす
      extra.push(this.createCommand(["adelay"], "[0:a]", null, 3, "silent"));
      // 結合したナレーションと無音を結合、フェードアウト3秒
      extra.push(
        this.createCommand(["acrossfade"], "[mix][silent]", null, 3, "mix")
      );
    }
    // 前後に無音を追加
    extra.push(
      this.createCommand(["concat"], "[0:a][mix][0:a]", null, 3, null)
    );

    // MIX処理実施
    return new Promise(async (resolve, reject) => {
      let f = this.getFFMpeg();
      let totalDuration = 0;
      for (var x of paths) {
        f.input(x).ffprobe((err, data) => {
          // BGM以外のおおよそ合計時間を取得
          if (!data.format.filename.includes("bgm")) {
            // 音源間でディレイを入れているので暫定値をプラス
            totalDuration += parseInt(data.format.duration) + 3;
          }
        });
      }
      // 処理実行
      f.complexFilter([...options, ...extra])
        .on("start", (command) => {
          console.debug(command);
        })
        .on("progress", (progress) => {
          let timemark = progress.timemark.split(":");
          let duration = parseInt(timemark[1]) * 60 + parseInt(timemark[2]);
          if (callback)
            callback({
              progress: {
                ...progress,
                duration: duration,
              },
              totalDuration: totalDuration,
            });
        })
        .on("end", (stdout, stderr) => {
          console.debug(stdout, stderr);
          resolve();
        })
        .on("error", function (err) {
          console.error(`error = ${err}`);
          reject(err);
        })
        .save(output);
    });
  };

  proto.getDuration = function (input) {
    // CMの秒数を取得
    return new Promise((resolve, reject) => {
      ffmpeg(input).ffprobe(0, (err, data) => {
        if (err) return reject(err);
        resolve(data.format.duration);
      });
    });
  };

  /// ; が必要ないため、createCommandをここで上書き
  proto.createCommand = function (process, index, volume, num, div) {
    const command = {
      silent: `silenceremove=stop_periods=-1:stop_duration=1:stop_threshold=-90dB`,
      volume: `volume=${volume / 100}`,
      adelay: `adelay=${num}s|${num}s`,
      apad: `apad=pad_dur=${num}`,
      aloop: `aloop=${num}:2.14748e+009`,
      concat: `concat=n=${num}:v=0:a=1`,
      amix: `amix=duration=shortest:weights=2 1`,
      acrossfade: `acrossfade=d=${num}`,
      afadeloop: `asplit[first][loop];[loop]afade=t=in:st=0:d=${num},aloop=-1:2.14748e+009[loop];[first][loop]concat=n=2:v=0:a=1`,
    };

    let res = `${index}`;
    let options = [];
    for (const key of process) {
      if (key in command) {
        options.push(command[key]);
      }
    }
    res += options.join();
    if (div) {
      res += `[${div}]`;
    }
    return res;
  };

  // mp3変換 録音音源
  proto.toMp3 = function (input, output) {
    return new Promise((resolve, reject) => {
      ffmpeg(input)
        .format("mp3")
        .on("data", (data) => {
          console.log(data);
        })
        .on("end", (stdout, stderr) => {
          console.log(stdout, stderr);
          resolve();
        })
        .on("error", function (err) {
          console.error(`error = ${err}`);
          reject(err);
        })
        .save(output);
    });
  };

  // wav変換 コンバート
  proto.toWav = function (input, output) {
    return new Promise((resolve, reject) => {
      ffmpeg(input)
        .audioCodec("pcm_s16le")
        .audioChannels(2)
        .audioFrequency(44100)
        .addOption("-map_metadata", -1)
        .addOption("-flags", "+bitexact")
        .format("wav")
        .on("end", (stdout, stderr) => {
          console.debug(stdout, stderr);
          resolve();
        })
        .on("error", function (err) {
          console.error(`error = ${err}`);
          reject(err);
        })
        .save(output);
    });
  };

  // ラウドネス値取得
  proto.getLoudnorm = function (
    input,
    params = { I: "-24.0", LRA: "+20.0", tp: "-2.0" }
  ) {
    return new Promise((resolve, reject) => {
      ffmpeg(input)
        .withAudioFilter(
          `loudnorm=I=${params.I}:LRA=${params.LRA}:tp=${params.tp}:print_format=json`
        )
        .addOption("-f", "null")
        .on("end", (stdout, stderr) => {
          try {
            console.debug(stdout, stderr);
            const json = stderr.substring(stderr.indexOf("{"));
            const data = JSON.parse(json.toString());
            resolve(data);
          } catch (e) {
            reject(e);
          }
        })
        .on("error", function (err) {
          console.error(`error = ${err}`);
          reject(err);
        })
        .save("-");
    });
  };

  // ラウドネス調整 + 音圧調整
  proto.runLoudnorm = function (
    input,
    output,
    params = { I: "-24.0", LRA: "+20.0", tp: "-2.0" }
  ) {
    return new Promise((resolve, reject) => {
      ffmpeg(input)
        .withAudioFilter(
          `loudnorm=I=${params.I}:LRA=${params.LRA}:tp=${params.tp}:measured_I=${params.input_I}:measured_LRA=${params.input_LRA}:measured_tp=${params.input_tp}:measured_thresh=${params.input_thresh}:offset=${params.target_offset},acompressor=threshold=-35dB:ratio=1.7:attack=200,alimiter=limit=-17dB:level=false:level_out=17dB`
        )
        .audioFrequency(44100)
        .format("wav")
        .on("end", (stdout, stderr) => {
          console.debug(stdout, stderr);
          resolve();
        })
        .on("error", function (err) {
          console.error(`error = ${err}`);
          reject(err);
        })
        .save(output);
    });
  };

  // ラウドネス調整 + HE-AACv2化
  proto.runLoudnormConvert = function (
    input,
    output,
    params = { input_I: "-17.0" }
  ) {
    return new Promise((resolve, reject) => {
      let filter = `volume=0dB`;
      if (params.input_I > -17.5) {
        filter = `volume=-${parseFloat(params.input_I) + 17.5}dB`;
      }
      ffmpeg(input)
        .withAudioFilter(filter)
        .audioCodec("libfdk_aac")
        .audioChannels(2)
        .audioFrequency(48000)
        .addOption("-profile:a", "aac_he_v2")
        .addOption("-ab", "48k")
        .on("end", (stdout, stderr) => {
          console.debug(stdout, stderr);
          resolve();
        })
        .on("error", function (err) {
          console.error(`error = ${err}`);
          reject(err);
        })
        .save(output);
    });
  };
};
