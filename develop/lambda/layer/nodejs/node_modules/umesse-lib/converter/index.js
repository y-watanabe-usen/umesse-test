'use strict';

const fs = require('fs');
const path = require('path');

const { debuglog, constants } = require('../constants');

var UMesseConverter = function (s3Manager) {
  this.s3Manager = s3Manager;
  this.ffmpeg = `ffmpeg -hide_banner`;
  this.basePath = '/tmp/umesse';
  return require('umesse-lib/converter/fluent-ffmpeg-processor')(UMesseConverter.prototype);
}
UMesseConverter.prototype.getWorkDir = function (unisCustomerCd, cmId) {
  return path.join(this.basePath, unisCustomerCd, 'mix', cmId);
}
UMesseConverter.prototype.buildGenerateCM = async function (unisCustomerCd, cmId, materials, output) {
  const workDir = this.getWorkDir(unisCustomerCd, cmId);
  const has = {
    startChime: "startChime" in materials,
    endChime: "endChime" in materials,
    bgm: "bgm" in materials,
  };
  console.log(`proto.generateCm()`);

  let paths = "-i /tmp/umesse/silent.mp3 ";
  let options = "";
  let extra = "";
  let index = 0;

  // S3からファイル取得、コマンド作成
  for (let [key, value] of Object.entries(materials).sort()) {
    debuglog(JSON.stringify({ key: key, value: value }));
    let fileName = "";

    switch (key) {
      case "narrations":
        let count = 0;
        let narrations = "";

        for (let v of value) {
          let target = `narration/${v.id}.mp3`;
          let bucket = constants.s3Bucket().contents;

          if (v.category == constants.resourceCategory.RECORDING || v.category == constants.resourceCategory.TTS) {
            // レコーディング音源orTTS音源の場合
            target = `${unisCustomerCd}/${v.category}/${v.id}.mp3`;
            bucket = constants.s3Bucket().users;
          }

          fileName = `narration_${++count}`;
          if (!(await this.getContents(bucket, target, workDir, `${fileName}.mp3`)))
            throw "getObject failed";
          paths += `-i ${workDir}/${fileName}.mp3 `;
          narrations += `[${fileName}]`;
          // 無音カット ボリューム調整　末尾に3秒無音追加
          options += this.createCommand(["silent", "volume", "apad"], `[${++index}:a]`, v.volume, 3, fileName);
        }
        // ナレーションを結合
        extra += this.createCommand(["concat"], narrations, null, count, "mix");
        if (has.bgm) {
          // BGMがある場合は、前後に3秒無音追加
          extra += this.createCommand(["adelay", "apad"], "[mix]", null, 3, "mix");
        }
        break;

      case "startChime":
        fileName = "start_chime";
        if (!(await this.getContents(constants.s3Bucket().contents, `chime/${value.id}.mp3`, workDir, `${fileName}.mp3`)))
          throw "getObject failed";
        paths += `-i ${workDir}/${fileName}.mp3 `;
        // 無音カット ボリューム調整　末尾に1秒無音追加
        options += this.createCommand(["silent", "volume", "apad"], `[${++index}:a]`, value.volume, 1, fileName);
        break;

      case "endChime":
        fileName = "end_chime";
        if (!(await this.getContents(constants.s3Bucket().contents, `chime/${value.id}.mp3`, workDir, `${fileName}.mp3`)))
          throw "getObject failed";
        paths += `-i ${workDir}/${fileName}.mp3 `;
        // 無音カット ボリューム調整　頭にBGMあり3秒、BGMなし1秒無音追加
        options += this.createCommand(["silent", "volume", "adelay"], `[${++index}:a]`, value.volume, has.bgm ? 3 : 1, fileName);
        break;

      case "bgm":
        fileName = "bgm";
        if (!(await this.getContents(constants.s3Bucket().contents, `bgm/${value.id}.mp3`, workDir, `${fileName}.mp3`)))
          throw "getObject failed";
        paths += `-i ${workDir}/${fileName}.mp3 `;
        // 無音カット ボリューム調整　BGMを無限ループ
        options += this.createCommand(["silent", "volume", "aloop"], `[${++index}:a]`, value.volume, -1, fileName);
        break;
    }
  }

  if (has.bgm) {
    // 結合したナレーションとBGMをMIX
    extra += this.createCommand(["amix"], "[mix][bgm]", null, null, "mix");
  }
  if (has.startChime) {
    // 結合したナレーションと開始チャイムを結合
    extra += this.createCommand(["concat"], "[start_chime][mix]", null, 2, "mix");
  }
  if (has.endChime) {
    // 結合したナレーションと終了チャイムを結合、フェードアウト3秒
    extra += this.createCommand(["acrossfade"], "[mix][end_chime]", null, 3, "mix");
  } else if (!has.endChime && has.bgm) {
    // 無音を3秒に伸ばす
    extra += this.createCommand(["adelay"], "[0:a]", null, 3, "silent");
    // 結合したナレーションと無音を結合、フェードアウト3秒
    extra += this.createCommand(["acrossfade"], "[mix][silent]", null, 3, "mix");
  }
  // 前後に無音を追加
  extra += this.createCommand(["concat"], "[0:a][mix][0:a]", null, 3, null);

  // MIX処理実施
  return `${this.ffmpeg} ${paths} -filter_complex '${options}${extra}' -y ${output}`;
}
UMesseConverter.prototype.buildGetDuration = function (input) {
  // CMの秒数を取得
  return `${this.ffmpeg} -hide_banner -i ${input} 2>&1 | \
        grep 'Duration' | cut -d ' ' -f 4 | cut -d '.' -f 1`;
}

UMesseConverter.prototype.getContents = async function (bucket, target, outputPath, outputFileName) {
  try {
    const res = await this.s3Manager.get(bucket, target);
    if (!res || !res.Body) throw "getObject failed";
    fs.writeFileSync(`${outputPath}/${outputFileName}`, res.Body);
    return true;
  } catch (e) {
    console.log(e);
    return false;
  }
}

UMesseConverter.prototype.createCommand = function (process, index, volume, num, div) {
  const command = {
    silent: `silenceremove=stop_periods=-1:stop_duration=1:stop_threshold=-90dB`,
    volume: `volume=${volume / 100}`,
    adelay: `adelay=${num}s|${num}s`,
    apad: `apad=pad_dur=${num}`,
    aloop: `aloop=${num}:2.14748e+009`,
    concat: `concat=n=${num}:v=0:a=1`,
    amix: `amix=duration=shortest`,
    acrossfade: `acrossfade=d=${num}`,
  };

  let res = `${index}`;
  let options = [];
  for (const key of process) {
    if (key in command) {
      options.push(command[key]);
    }
  }
  res += options.join();
  if (div) {
    res += `[${div}];`;
  }
  return res;
}
module.exports = UMesseConverter